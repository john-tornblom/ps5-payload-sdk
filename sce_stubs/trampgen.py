#!/usr/bin/env python3
# encoding: utf-8
# Copyright (C) 2023 John TÃ¶rnblom
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING. If not see
# <http://www.gnu.org/licenses/>.

import logging
import os
import string
import sys

import xml.etree.ElementTree as ET

from pathlib import Path
from elftools.elf.elffile import ELFFile


logger = logging.getLogger('trampgen')


# read NIDs from nid_db.xml
NID_DB = (os.path.dirname(__file__) or '.') + '/nid_db.xml'
nid_map = {entry.get('obf'): entry.get('sym')
           for entry in ET.parse(NID_DB).getroot()}


# Header template
tmpl_head = string.Template('''/*
 This file was generated by trampgen.py, do not edit manually!
*/
''')


# Dependencies template
tmpl_deps = string.Template('''
int sprx_dlsym(unsigned int handle, const char *symname, void *addr);
int sprx_dlopen(const char* libname, unsigned short *handle);
int sprx_dlclose(unsigned short handle);
''')


# Initialization template
tmpl_init = string.Template('''
static unsigned short __handle = 0;

static void __attribute__((constructor(102)))
__constructor(void) {
  sprx_dlopen("$name", &__handle);
}

static void __attribute__((destructor(102)))
__destructor(void) {
  sprx_dlclose(__handle);
}
''')


# Function template
tmpl_func = string.Template('''
asm(".intel_syntax noprefix\\n"
    ".global $name\\n"
    ".type $name @function\\n"
    "$name:\\n"
    "jmp qword ptr [rip + __ptr_$name]\\n");

asm(".intel_syntax noprefix\\n"
    ".type __load_and_call_$name @function\\n"
    "__load_and_call_$name:\\n"
    "push rdi\\n"
    "push rsi\\n"
    "push rdx\\n"
    "push rcx\\n"
    "push r8\\n"
    "push r9\\n"
    "call __load_$name\\n"
    "pop r9\\n"
    "pop r8\\n"
    "pop rcx\\n"
    "pop rdx\\n"
    "pop rsi\\n"
    "pop rdi\\n"
    "jmp qword ptr [rip + __ptr_$name]\\n");

void __load_and_call_$name();
static __attribute__ ((used)) void* __ptr_$name = &__load_and_call_$name;

static __attribute__ ((used)) void
__load_$name(void) {
  sprx_dlsym(__handle, "$name", &__ptr_$name);
}''')


def guess_library_index(filename):
    '''
    Assume the library index with the most number of symbols is the one
    exported.
    '''
    with open(filename, 'rb') as f:
        elf = ELFFile(f)
        cntmap = dict()

        for segment in elf.iter_segments():
            if segment.header.p_type != 'PT_DYNAMIC':
                continue

            for sym in segment.iter_symbols():
                if sym.entry['st_shndx'] == 'SHN_UNDEF':
                    continue

                if not sym.name:
                    continue

                try:
                    nid, lid, mid = sym.name.split('#')
                    cnt = cntmap.get(lid, 0)
                    cntmap[lid] = cnt + 1
                except:
                    pass

        if cntmap:
            return max(cntmap, key=cntmap.get)


def symbols(sym_type, filename, library_index):
    '''
    yield symbol names in PT_DYNAMIC segments using the NID lookup table
    'nid_db.xml'.
    '''
    with open(filename, 'rb') as f:
        elf = ELFFile(f)

        for segment in elf.iter_segments():
            if segment.header.p_type != 'PT_DYNAMIC':
                continue

            for sym in segment.iter_symbols():
                if sym_type != sym.entry['st_info']['type']:
                    continue

                if sym.entry['st_shndx'] == 'SHN_UNDEF':
                    continue

                if not sym.name:
                    continue

                nid, lid, mid = sym.name.split('#')
                if not library_index in (None, lid):
                    continue

                if not nid in nid_map:
                    logger.warning(f'skipping unknown NID {nid}')
                    continue

                yield nid_map[nid]


if __name__ == '__main__':
    logging.basicConfig(level=logging.WARNING)

    libname = Path(sys.argv[1]).stem
    libindex = guess_library_index(sys.argv[1])
    funcs = sorted(symbols('STT_FUNC', sys.argv[1], libindex))
    gvars = sorted(symbols('STT_OBJECT', sys.argv[1], libindex))

    if not funcs: # and not gvars:
        sys.exit(0)

    print(tmpl_head.substitute())
    print(tmpl_deps.substitute())

    if libname in ('libkernel', 'libkernel_sys', 'libkernel_web'):
        print()
        print('static unsigned short __handle = 0x2001;')
        print()
    else:
        print(tmpl_init.substitute(name=libname))

    for symname in funcs:
        print(tmpl_func.substitute(name=symname))
